<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Chanseok Kang">
<meta name="dcterms.date" content="2023-11-09">
<meta name="description" content="Sequential Approach to evaluate Offline RL algorithms as a function of the training set size">

<title>Chans Lecture Note - Bridging the Gap Between Offline and Online Reinforcement Learning Evaluation Methodologies</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-0JHM3R8BEZ"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-0JHM3R8BEZ', { 'anonymize_ip': true});
</script>
<style>html{ scroll-behavior: smooth; }</style>
<script>
MathJax = {
  loader: {
    load: ['[tex]/boldsymbol']
  },
  tex: {
    tags: "all",
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\\[','\\]']],
    processEscapes: true,
    processEnvironments: true,
    packages: {
      '[+]': ['boldsymbol']
    }
  }
};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
<script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6747875619665490" crossorigin="anonymous"></script>
<link href="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.css" rel="stylesheet">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Chans Lecture Note</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../publication/index.html" rel="" target="">
 <span class="menu-text">Publication</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-posts" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
 <span class="menu-text">Posts</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-posts">    
        <li>
    <a class="dropdown-item" href="../../../index.html" rel="" target="">
 <span class="dropdown-text">English</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../posts/kr.html" rel="" target="">
 <span class="dropdown-text">한글</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/goodboychan" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/chanseokk/" rel="" target=""><i class="bi bi-linkedin" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-page-left">
      <h1 class="title">Bridging the Gap Between Offline and Online Reinforcement Learning Evaluation Methodologies</h1>
            <p class="subtitle lead">Offline Sequential Evaluation</p>
                  <div>
        <div class="description">
          Sequential Approach to evaluate Offline RL algorithms as a function of the training set size
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">PaperReview</div>
                <div class="quarto-category">ReinforcementLearning</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Chanseok Kang </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 9, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#tldr" id="toc-tldr" class="nav-link active" data-scroll-target="#tldr">TL;DR</a></li>
  <li><a href="#내용-소개" id="toc-내용-소개" class="nav-link" data-scroll-target="#내용-소개">내용 소개</a>
  <ul class="collapse">
  <li><a href="#squential-evaluation-of-offline-rl-algorithms" id="toc-squential-evaluation-of-offline-rl-algorithms" class="nav-link" data-scroll-target="#squential-evaluation-of-offline-rl-algorithms">Squential Evaluation of Offline RL Algorithms</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block column-page-left" id="quarto-document-content">




<ul>
<li>저자: Shivakanth Sujit, Pedro H.M Braga, Jorg Bornschein, Semira Ebrahimi Kahou</li>
<li>발표: Offline Reinforcement Learning Workshop, NeurIPS 2022</li>
<li><a href="https://arxiv.org/abs/2212.08131">논문</a></li>
<li><a href="https://openreview.net/forum?id=lT4dOUtZYZ">OpenReview</a></li>
</ul>
<section id="tldr" class="level2">
<h2 class="anchored" data-anchor-id="tldr">TL;DR</h2>
<p>Deep RL에서 가장 큰 어려움 중 하나는 학습을 위해서는 환경과의 interaction이 수없이 이뤄져야 한다는 것이다. 만약 로봇과 같이 interaction에서 소요되는 비용이 큰 경우에는 적용하기 어려운 부분이 존재한다. 이러한 문제를 해결하기 위해서 처음부터 환경과의 interaction 없이 존재하는 log만으로 학습하는 Offline RL 기법이 제안되고 있다. 하지만 Online RL과는 다르게 Offline RL을 평가하기 위한 어떤 정형화된 evaluation method가 많지 않고, 이 논문에서는 log를 활용하여 Offline RL 알고리즘을 Sequantial Evaluation 하는 방법에 대해서 소개하고 있다. Sequential Evaluation을 통해서 학습 과정에서 사용되는 데이터를 더 효율적으로 활용함과 동시에 Offline과 Online 사이에 발생하는 distribution shift에 대해서 적절하게 대응할 수 있다는 것이 주요 특징이다. 사실 워크샵 논문이라 내용이 길지 않을 뿐더러, 논문에서 소개하고 있는 방식이 어떤 수식에 의존한 알고리즘에 대한 내용이 아니라 evaluation을 하는 process에 대한 내용이어서 내용이 어렵지가 않다.</p>
</section>
<section id="내용-소개" class="level2">
<h2 class="anchored" data-anchor-id="내용-소개">내용 소개</h2>
<section id="squential-evaluation-of-offline-rl-algorithms" class="level3">
<h3 class="anchored" data-anchor-id="squential-evaluation-of-offline-rl-algorithms">Squential Evaluation of Offline RL Algorithms</h3>
<p>Offline RL 알고리즘에 대한 evaluation을 하는 방법 중 하나는 dataset에 대해서 training을 여러 epoch 수행하는 것인데, 이러한 방식은 몇가지 문제를 가지고 있다. 첫째로, training시 모든 data를 사용하기 때문에 사용된 알고리즘이 sample efficiency 측면에서 좋은지를 평가하기 어렵다는 것이다. 이로 인해서 실제 환경에 적용했을 때도, 현재 사용하고 있는 학습데이터의 양이 충분한지 여부를 판단하기 어려운 문제로 이어진다. 또한, log를 쌓을 때 사용된 policy의 quality에 따라서 distribution change가 존재할 수 있다. 그리고 마지막으로, Online RL에서 사용되는 Evaluation 방식을 Offline RL에서 그대로 활용하기 때문에, 실질적으로 Offline RL의 성능이 어느 정도인지 (적어도 Online RL과 비교하려해도) 어려운 문제가 있다.</p>
<p>그래서 논문에서 제안하는 방식은 시간에 따라서 학습하는 agent가 사용할 수 있는 데이터의 비율을 점점 변화시키면서 해당 데이터를 바탕으로 evaluation을 수행하는 것이다. (전제 데이터를 한번에 다 쓰지 말고…) 이를 위해서 기존의 Online Deep RL에서 많이 사용되는 <strong>replay-buffer</strong> 기반의 training scheme을 활용하게 된다. 대신 Online RL에서처럼 현재 학습하고 있는 agent의 experience를 넣는 것이 아니라, offline log를 시간에 따라서 조금씩 추가하는 것이 핵심이다. 그래서 새롭게 추가되는 샘플들과 buffer에서 sampling된 mini batch data를 바탕으로 gradient update를 수행한다. 상세한 알고리즘의 구성은 <a href="#offline-sequential-evaluation">Algorithm 1</a> 과 같다.</p>
<div id="offline-sequential-evaluation" class="pseudocode-container" data-alg-title="Algorithm" data-line-number-punc=":" data-no-end="false" data-pseudocode-index="1" data-comment-delimiter="//" data-indent-size="1.2em" data-line-number="true">
<div class="pseudocode">
\begin{algorithm} \caption{Sequential Evaluation in the offline setting} \begin{algorithmic} \Input{ Algorithm $A$, Offline data $\mathcal{D} = \{ s_t, a_t, r_t, s_{t+1}\}_{t=1}^{T_0}$, increment-size $\gamma$, gradient steps per increment $K$} \State{Replay-buffer $\mathcal{B} \gets \{s_t, a_t, r_t, s_{t+1}\}_{t=1}^{T_0}$} \State{$t \gets T_0$} \While{$t &lt; T$} \State{Update replay-buffer $ \mathcal{B} \gets \mathcal{B} \cup \{s_t, a_t, r_t, s_{t+1}\}_{t}^{t+\gamma}$} \State{Sample a training batch, ensure new data is included: batch $\sim \mathcal{B}$} \State{Perform training step with $A$ on batch} \State{$t \gets t + \gamma$} \For{$j=1, \cdots, K$} \State{Sample a training batch $\sim \mathcal{B}$} \State{Perform training step with $A$ on batch} \EndFor \EndWhile \end{algorithmic} \end{algorithm}
</div>
</div>
<p>위 알고리즘을 통해서 epoch-style로 학습할 때 발생하는 문제를 대응할 수 있는데, 먼저 데이터를 증가시키는 정도를 나타내는 <span class="math inline">\(\gamma\)</span>와 학습을 수행하는 횟수를 나타내는 <span class="math inline">\(K\)</span> 를 다르게 함으로써, dataset의 size가 변화함에 따라서 성능 변화의 추이(예를 들어서 어떤 size에서 bottleneck이 발생하는지…)를 확인할 수 있다. 그리고 알고리즘을 보면 알겠지만, Online RL에서 환경과의 interaction을 여러 번 수행하면서 evaluation 하는 것과 비슷한 형태로 되어 있어서, 이와 같은 방식을 통해서 replay-buffer의 size에 따라서 Offline RL의 성능 변화가 발생하는 것을 확인할 수 있다. 또한 모든 offline log가 replay-buffer에 들어간 이후에 online finetune을 수행하면서도 새롭게 추가된 데이터를 활용할 수 있기 때문에, Offline-to-Online RL 환경에서 Seamless하게 evaluation 수행할 수 있다. 무엇보다도, 알고리즘 자체를 개선했다기 보다는 데이터를 어떻게 활용할 것인지에 대한 방법을 제시한 것이기 때문에, 기존의 학습 과정을 크게 수정하지 않고도 적용할 수 있다는 장점이 있다.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="kcsgoodboy/en" data-repo-id="R_kgDOIixJIQ" data-category="General" data-category-id="DIC_kwDOIixJIc4CTiz-" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">Copyright 2023, Chanseok Kang</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>
<script src="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.js" type="text/javascript"></script>
<script type="text/javascript">
(function(d) {
  d.querySelectorAll(".pseudocode-container").forEach(function(el) {
    let pseudocodeOptions = {
      indentSize: el.dataset.indentSize || "1.2em",
      commentDelimiter: el.dataset.commentDelimiter || "//",
      lineNumber: el.dataset.lineNumber === "true" ? true : false,
      lineNumberPunc: el.dataset.lineNumberPunc || ":",
      noEnd: el.dataset.noEnd === "true" ? true : false,
      titlePrefix: el.dataset.algTitle || "Algorithm"
    };
    pseudocode.renderElement(el.querySelector(".pseudocode"), pseudocodeOptions);
  });
})(document);
(function(d) {
  d.querySelectorAll(".pseudocode-container").forEach(function(el) {
    titleSpan = el.querySelector(".ps-root > .ps-algorithm > .ps-line > .ps-keyword")
    titlePrefix = el.dataset.algTitle;
    titleIndex = el.dataset.chapterLevel ? el.dataset.chapterLevel + "." + el.dataset.pseudocodeIndex : el.dataset.pseudocodeIndex;
    titleSpan.innerHTML = titlePrefix + " " + titleIndex + " ";
  });
})(document);
</script>



<script src="../../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>